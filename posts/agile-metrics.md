---
layout: post
title: "Описание метрик команды. Какие метрики в команде можно собирать быстро. А какие должны настояться."
date: 2024-11-03
---


Довелось немного погрузиться в теорию отслеживания метрик работы команды и хотел бы поделиться идеями о том, как можно без больших усилий собирать осязаемые результаты спринта. Помимо этого немного расскажу о некоторых метриках, которые собираются в масштабах проектов.

Рассмотрим метрики из **Scrum** и **Kanban**. Открытия Америки не будет, я использую существующие подходы, но для тех, кто раньше не сталкивался с этими метриками может быть полезно о них узнать. 

<br><br>

## В данной статье рассматриваются
1. [Scrum метрики.](#scrum-metrics)
    - [Производительность команды (Velocity).](#velocity)
    - [Диаграмма сгорания (Burnout chart)](#burnout)
    - [Фокус фактор](#ff)
2. [Kanban метрики.](#kanban)
    - [Время цикла (Cycle time)](#cycletime)
    - [Диаграмма накопления задач (Cumulative Flow Diagram - CFD)](#cfd)
3. [Метрики, выделенные самостоятельно.](#custom)
    - [Спринт идеальный и реальный](#sprint-compare)
    - [Спадания состояния Pull Request’ов](#rpgpr)
4. [Метрики на длительном периоде наблюдений.](#long-metrics)
    - [Производительность команды (Velocity) в масштабах проекта](#long-velocity)
    - [Вероятностная оценка времени выполнения](#percent)

<br><br>

# Прежде всего, определимся с целью и объектами обсуждения. 

> Для Agile-команды метрики — это **приборная панель самолета и регулярный чек-ап в одном флаконе**. 

Метрики помогают понять, как идут дела, где могут возникнуть или уже возникли проблемы и что нужно улучшить. 

Без "приборов" команда как будто идет с закрытыми глазами, а показатели метрик помогают вовремя заметить и решить трудности в процессах. 

Не всегда отсутствие метрик говорит о том, что команде неизвестно о проблемах или успехах. 
Это может быть видно:
- При формальной проверке результатов (уложились ли мы в сроки и бюджеты);
- При ретроспективном анализе того, что мешало команде на спринте;
- Это может влиять эмоционально на членов команды — кажется, что что то не так. 

Метрики в этом случае скорее плацдарм — общий язык, отправная точка, которая позволяет следить за тем, как меняются показатели во времени. И использовать общий знаменатель в обсуждении работы команды, чтобы смотреть — как меняется один и тот же показатель в течение проекта. 

Зачастую рассматриваются два вида метрик — относящимся к фреймворку или методу управления разработкой. Методики **Scrum** позволяют определить скорость работы команды и темп завершения задач в рамках спринта, а метрики из **Kanban** — сколько времени задачи проводят в разных статусах.

<br><br>


# <a id="scrum-metrics">Метрики Scrum. Анализируем производительность</a> 
Данные метрики нацелены на то, чтобы показать как быстро выполняются работы и в каком объеме. Знание об этом позволяет нам регулировать размер ожиданий на спринт или фокус-фактор.

<br>

## <a id="velocity">Производительность команды (Velocity)</a> 
Производительность команды показывает, сколько Story Points команда может завершить в течение спринта. 

**Story Point** — это единица измерения для оценки сложности задачи. Метрику нужно использовать в планировании будущих спринтов и прогнозировании сроков завершения проекта.

**Velocity** стоит рассматривать как тренд, а не как абсолютное значение, так как она может варьироваться от спринта к спринту. Данные за несколько спринтов помогут спланировать следующие итерации — чем больше данных, тем точнее команда может оценивать задачи в спринте и прогнозируемо реализовывать планы. 

> Более того, в масштабах проектов этот показатель позволяет считать вероятность выполнения стори в указанное время. Этакая заводская разметка на спидометр. Чтобы не отвлекаться, о метриках на длинную дистанцию я расскажу в конце статьи.


![velocity](https://simpleone.ru/_next/image?url=https%3A%2F%2F06f3557d98f44a6c9896014c980c5b74-ds1.s3.itgstore.io%2Fgrowth-driver%2Fpublic%2Fsimpleone%2Fwp-content%2Fuploads%2F2024%2F08%2Fspeed.png&w=3840&q=100)

<br>

## <a id="burnout">Диаграмма сгорания (Burnout chart)</a> 
**Диаграмма сгорания** — это график, который показывает, какой объем работы осталось сделать в спринте и какой объем работы уже сделан, насколько равномерно списываются трудозатраты в команде.

![burnout](https://simpleone.ru/_next/image?url=https%3A%2F%2F06f3557d98f44a6c9896014c980c5b74-ds1.s3.itgstore.io%2Fgrowth-driver%2Fpublic%2Fsimpleone%2Fwp-content%2Fuploads%2F2024%2F08%2Fburndown-chart.png&w=3840&q=100)

- На оси X отражены рабочие дни спринта,
- На оси Y - количество Story Points,
- Линия "Идеальное сжигание" показывает количество задач будет снижаться, если мы будем выполнять их равномерно,
- Реальная линия показывает фактическое количество оставшейся работы в каждый из дней.

График сгорания задач помогает команде отслеживать прогресс и определять, идет ли работа над задачами в спринте в соответствии с планом. Значительные отклонения реальной линии от идеальной указывают на проблемы в планировании — команда взяла в спринт намного больше или меньше задач, чем нужно.

<br>

## <a id="ff">Фокус фактор</a> 
Под **«фокус-фактором»** понимается некий коэффициент, отражающий отношение производительности существующей команды к производительности «идеальной» команды программистов. 

Для этого фактическое значение Velocity за спринт разделим на сумму плановых часов по запланированным в спринте задачам:

![ff](https://i.ibb.co/6vcRmTX/image-2.png)

Измерение этой метрики  позволяет нам отслеживать динамику того, насколько команда адекватно планирует спринты и выполняет запланированные объемы работ, превращая их в ценность для клиента.

"Идеальная" команда делает 100% запланированной работы, но в реальности фокус фактор позволяет нам понимать, сколько из запланированного мы делаем и учитывать это при планировании и формировании работ на спринт.

<br><br>

# <a id="kanban"> Метрики Kanban</a> 
**Kanban** — метод гибкого управления разработкой, его метрики фокусируются на конвейере разработки работы и времени выполнения задач. Логично, что наиболее хорошо метрики работают в содружестве с Kanban доской проекта, однако поскольку конкретно наша команда пока не использует доску - никто не мешает нам считать эти метрики вручную. Если же доска в команде используется - TFS и Jira умеют автоматически показывать эти метрики при использовании доски.

<br>

## <a id="cycletime">Время цикла (Cycle time)</a>
Данная метрика показывает время, которое задача проводит в активной разработке. То есть это путь задачи от статуса **"В работе"** до **"Завершено"**. В зависимости от вашего подхода к работе по пути задача может переходить в статусы *"Рецензирование", "Тестирование", "Приемка", и другие*.

Важно, что это время, которое команда активно работала над завершением задачи и ее поставкой.

Считается Cycle Time в рабочих днях как **разница даты завершения задачи и даты ее взятия в работу**.
> Например, если задача начата в пятницу и в этот же день закончена - ее cycle time - 1 день. Если же мы взяли ее в ПН и закончили в ПТ - то 5.

В нашем случае мы считаем Cycle Time для каждой задачи, а затем для User Story по ее задачам. Cycle time для User Story - это `"дата завершения всех задач стори" минус " дата взятия в работу первой задачи"`

![cycle time](https://i.ibb.co/82J4h9B/image-5.png)
- Первую задачу взяли 14.10, а закончили стори 16.10. Получается над этой стори работали 3 дня - 14, 15, 16.

Эта метрика позволяет оценить скорость работы команды и эффективность процесса разработки. Уменьшение Cycle Time обычно указывает на повышение производительности команды.

<br>

## <a id="cfd">Диаграмма накопления задач (Cumulative Flow Diagram - CFD)</a>
**Диаграмма накопления задач** или Кумулятивная диаграмма потока (**CFD**) — это график, который показывает количество задач в разных состояниях (например, «В работе», «Ревью», «Завершено») с течением времени. В диаграмме нужно отразить все состояния, которые может проходить задача перед завершением.

Считается CFD по результатам Cycle time - раз у нас есть данные о том, в какие дни задача выполнялась - мы можем посчитать количество задач в каждом из состоянии на этот день.
В нашем случае мы смотрим 4 состояния: 
- Wait,
- Active (в разработке),
- Testing,
- Closed.

Предположим, что мы анализируем 5 рабочих задач из таблицы [Cycle Time](#cycletime) выше. Посчитать состояние задачи в каждый из дней не сложно, в нашем случае это решилось одним хитрым условием Excel. 
![cfd table](https://i.ibb.co/bs3m2bW/image-6.png)
- Для каждой задачи мы смотрим, когда она была взята и завершена. В этом промежутке состояние задачи - Active, до него - Wait, после - Closed.
- Тестирование у нас помечается тэгом, поэтому активные задачи на тестирование будут попадать в состояние "Test" (в нашем примере - Task 5).
- Также в таблице считается количество задач на день в каждом из состоянии - "Total Wait", "Total Active" и так далее.

По нашим демонстрационным данным получается следующая диаграмма. 
![cfd short](https://i.ibb.co/WgbFJWj/image-7.png)
- По оси X отображается время
- По оси Y отображается количество задач
- Каждый статус задач представлен отдельной областью на графике

Поскольку данных мало, она не очень показательная, но она нужна, как итог вычислений нашего примера, прежде чем мы перейдем к более реальным графикам CFD.

> Данная диаграмма нужна, чтобы графически показать, что что-то идет не так. Нужно смотреть на высоту и длину каждой из осей. Если длина горизонтального отрезка большая - это говорит о проблемах и задержках в разработке. Если вертикальный отрезок для вида деятельности большой - это значит в этот день было много работ этой категории, что тоже может косвенно говорить о перегрузке.

Теперь, когда мы знаем из чего состоит CFD давайте посмотрим какую информацию из них можно почерпнуть.

<br>

## Общая информация на CFD
![cfd common](https://i.ibb.co/Zc89z1j/image-8.png)
- Во-первых, по CFD сразу можно отметить изменение объема работ – изменение верхней границы голубой области. 
- Во-вторых, увидеть как менялось количество элементов в работе (Work in Progress – WiP) и каково среднее время поставки (Production Lead Time – среднее время, необходимое для выполнения одной задачи).
- Можно апроксимировать линию "выполнено" и определить приблизительный срок окончания проекта.

CFD позволяет быстро увидеть аномалии в состояниях задач. Если график всегда стабильный и гладкий вы можете получить ту информацию, о которую мы только что обсудили, но реальная магия CFD проявляется в тот момент, когда в проекте возникают проблемы. 

<br>

## Анализ диаграммы и аномалии

Очень хорошо виды проблем или "аномалии" описаны в этой статье - [Анализ CFD, примеры проблем](https://kaiten.ru/blog/nakopitielnaia-diagramma-potoka/). Каждая из проблем сопровождается графиком и объяснением что там происходит. 

> **Настоятельно рекомендую прочитать статью**, если вы хотите узнать примеры базовых сигналов бедствия от CFD.

Теперь пример реальной диаграммы потока.
![real cfd](https://i.ibb.co/b6fcSBZ/image-14.png)
- Если вы прочитали статью об аномалиях, то, вероятно, видите, что больших проблем в диаграмме нет. Тестирования было немного, разработка шла стабильно и не росла критично.

Однако важно помнить, что CFD лишь показывает наличие проблемы и призывает к более глубокому анализу. Собственно в этом и есть основное назначение графика.
В нашем случае, например, один из тестировщиков был в отпуске, поэтому тестирование занимало сильно меньше времени, чем обычно.

<br><br>



# <a id="custom">Метрики вида "я его слепила из того, что было"</a>
В этой части я описал метрики, которые не являются базовыми для подходов **Kanban** и **Scrum**, однако в нашем случае мы решили последить за ними.

<br>

## <a id="sprint-compare"> Спринт идеальный и реальный</a>
Используя знание о нагрузке каждого человека на спринте мы можем сформировать его время работы в часах на каждый день для каждого из видов работ (разработка, тестирование, встречи, обучение и пр.)

Таким образом, мы можем примерно прикинуть сколько времени в день сможет работать команда над тем или иным видом работы. Если мы можем прикинуть сколько в день тратится на вид работ, мы можем построить "идеальный" спринт, где каждый день будет выполняться работа в отведенное время. Если мы знаем фокус фактор, то прикинуть количество "идеальных" часов к реальным не составит труда. 

Поэтому по фиксированному составу работ на спринт мы можем начать строить диаграмму спринта. Отмечая ячейки дней, когда задача будет взята в работу и закончена.
Считаем, что работы берутся сверху вниз по спринту, но также придерживаемся некоторых правил.
1) Если работа не влазит в 1 день - разбиваем работы и переносим на следующий день
2) Если задач больше, чем исполнителей и в течение дня не хватит времени чтобы переключиться и сделать другую задачу - переносим ее на следующий день

<br>

Давайте соберем таблицу на расматриваемом ранее примере с 5 задачами. 

> Предположим, что у нас **3 разработчика**, **1 тестировщик** и в обычный день мы можем делать по **10 SP**, однако на один из дней у нас запланирован созвон, который съест время работы и снизит мощность команды до **8 SP** в этот день.

Таким образом мы получим такую картину:

![ideal sprint](https://i.ibb.co/nfWZQ36/image-17.png)
- Всего 3 разработчика, поэтому Task 3 и Task 4 не влазят полностью в 1й день.
- Планируется, что к последнему дню вся разработка будет готова и останется только тестирование.

Данный "идеальный" спринт можно формировать в самом начале спринта. Он не является точным мерилом, но может показывать наши "идеальные" намерения на спринт.

<br>

Теперь давайте посмотрим, как выглядит реальный спринт
![alt text](https://i.ibb.co/XWcRDXp/image-18.png)
- В первый день разработчики были заняты другими задачами и не успели подключиться активно к работе,
- Во второй день одному из разработчиков, который закончил работать над задачей 4 получилось переключиться на задачу 2, но завершить он ее не успел,
- Как итог, в последний день - тестирование не могло приступить в начале дня и ждало, пока задача 2 будет завершена.


Несмотря на то, что в нашем примере US закрылась в запланированный день, реальный спринт может сильно отличаться от идеального. Более того, мы видим, что на спринте вместо того, чтобы идти по порядку, сначала была взята задача 4. Это отличное место, чтобы задать вопрос "Почему?"

Места, которые заметно отличаются от идеала показывают, что где то процесс планирования ошибся в оценках и это может стать поводом для анализа произошедшего.

<br>

## <a id="rpgpr"> Спадания состояния Pull Request'ов </a>
Если вы знакомы с жанром RPG или Roque-Like в играх, то вам понятна ситуация, когда дойдя практически до конца уровня ваш герой умирает и приходится начинать уровень заново. Давайте назовем это "спаданием в начало". Таким образом статисткой прохождения будет количество повторных прохождений уровня, перед успешным переходом на следующий.

Этим героем игры может быть наш Pull Request, а уровнями - его состояния.

![rpg](https://i.ibb.co/FzJw4TZ/image-15.png))

Предположим, что чтобы полностью пройти квест, PR должен пройти этапы
1) разработка и публикация PR,
2) рецензирование PR,
3) тестирование PR,
4) приемка PR.

При "смерти" каждый из уровней откатывает PR на предыдущий уровень или даже в самое начало. 

Рецензент нашел проблему в коде - **нужно править код**. Нашли проблемы в тестировании - **нужно править код, а после правок перерецензировать**. Не прошли приемку - **повторяем все проверки с начала**.

Таким образом для каждого PR мы можем считать сколько раз с каждого из состояний мы спадали на предыдущие уровни. 

Эта информация поможет нам определить "сложные" задачи, которые мы недооценили, но которые в процессе привели к откатам. Либо, к местам в системе, с которыми команде сложно справиться с первого раза.

<br><br>

# <a id="long-metrics">  Метрики длительностью на проекты. Долгоиграющая аналитика </a>
Кратко опишу, какие метрики собираются постоянно, но анализируются в масштабах проекта (4-6 спринтов).

<br>

## <a id="long-velocity"> Velocity в масштабах проекта </a>
Поскольку каждый спринт мы анализируем метрики, было бы здорово посмотреть как они меняются со времением. И самый простой способ это сделать - отметить точки на графике по каждому спринту. Из расмотренных метрик наиболее наглядно будет представлена метрика мощности.

Представим, что на проекте в 6 спринтов процент выполнения работ в каждом из них был следующим
|  № Спринта | % выполнения (Velocity)|
| -------- | --- |
| Спринт 1 | 70% |
| Спринт 2 | 59% |
| Спринт 3 | 80% |
| Спринт 4 | 50% |
| Спринт 5 | 75% |
| Спринт 6 | 80% |

Нанеся эти точки на график мы увидим тренд, который показывает, что в целом количество выполняемой работы растет

![alt text](https://i.ibb.co/Hh3MVLL/image-19.png)

Многие из описанных в статье метрик можно смотреть на горизонте проекта. Достаточно отмечать состояние каждой из метрик в отдельном спринте, а затем линейно сравнивать результаты.

<br>

## <a id="percent"> Вероятностная оценка времени выполнения </a>

Эта оценка покажет нам сколько времени статистически требуется команде для выполнения **ЛЮБУЮ** User Story с указанной вероятностью.

Для формирования данных для этого анализа нужно собрать 3 колонки за промежуток времени (чем больше - тем точнее):
- Часы
- Кол-во историй
- Нарастающее количество

Пример первых записей такой таблицы.

| Часы | Кол-во историй | Нарастающее количество |
| ---- | -------------- | ---------------------- |
| 1    | 35             | 35                     |
| 5    | 81             | 116                    |
| 10   | 6              | 122                    |
| 15   | 3              | 125                    |

Таблица показывает, что за все время наблюдений 35 US потребовали потратить на себя 1 час, 81 US заняли по пять часов каждая и так далее.


Когда таблица будет полностью заполнена, мы можем запустить наш анализ. Передаем на вход процент попадания и таблица высчитывает сколько из записей попадает в указаный персентиль и какое время выполнения для самой долгой US.

|  Наименование   |   Значение    |
| ---------------------------------------- | ----- |
| Процент попадания                        | 90%   |
| Общее количество историй                 | 125   |
| Кол-во историй, попадающих в прогноз     | 112,5 |
| Время, за которое делается процент задач | 1     |


Для 95%, например, значение оценки будет больше. 

|  Наименование   |   Значение    |
| ---------------------------------------- | ------ |
| Процент попадания                        | 95%    |
| Общее количество историй                 | 125    |
| Кол-во историй, попадающих в прогноз     | 118,75 |
| Время, за которое делается процент задач | 5      |

Таким образом, на наших данных мы выяснили, что в 95% случаев мы сделаем любую US, подобную тем, что мы раньше делали примерно за 5 часов.

Эта информация поможет при планировании, чтобы быстро прикинуть сроки, которые могут потребоваться для выполнения работы. 

<br><br>


## Автор статьи — Максим Гильман, программист. 
Пишу о разработке, языках программирования и работе в команде.

Мой блог  [“Перезагружать пробовали?”](https://t.me/reboot_repeatedly)

[Связаться со мной](https://t.me/reboot_repeatedly)
